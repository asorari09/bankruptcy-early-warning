# -*- coding: utf-8 -*-
"""portfolio

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o2onXIIBQqA8HsysUU_sAEAcYF06sosp
"""

# ===================================================================
# pages/4_üìä_Portfolio.py
# Portfolio Analysis ‚Äî Bankruptcy Early Warning Indicator
# Phase 2: Heatmap, Filters, Export Tools
# ===================================================================

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px

from utils.model_utils import load_model
from utils.feature_engineering import compute_features
from utils.visualization import inject_global_css
from utils.plot_helpers import plot_industry_heatmap
from utils.pdf_generator import generate_pdf

import io
import re

# ------------------------------------------------------------
# PAGE SETUP
# ------------------------------------------------------------
inject_global_css()

st.markdown("<h1 class='fade-in'>Portfolio Analysis</h1>", unsafe_allow_html=True)
st.markdown("### Analyze multiple companies to understand portfolio-wide bankruptcy risk.")


# ------------------------------------------------------------
# LOAD MODEL
# ------------------------------------------------------------
model = load_model()

# Required model input columns
REQUIRED_COLUMNS = [
    "current_assets", "cost_of_goods_sold", "depreciation_amortization",
    "ebitda", "inventory", "net_income", "total_receivables", "market_value",
    "net_sales", "total_assets", "total_long_term_debt", "ebit", "gross_profit",
    "total_current_liabilities", "retained_earnings", "total_revenue",
    "total_liabilities", "total_operating_expenses", "MajorGroup"
]


# ------------------------------------------------------------
# FILE UPLOADER
# ------------------------------------------------------------
uploaded_file = st.file_uploader(
    "Upload CSV or Excel file",
    type=["csv", "xlsx"],
    help="File must contain one row per company with appropriate financial fields."
)

if uploaded_file:

    try:
        if uploaded_file.name.endswith(".csv"):
            df = pd.read_csv(uploaded_file)
        else:
            df = pd.read_excel(uploaded_file)

        st.success(f"Loaded {df.shape[0]} companies.")

    except Exception as e:
        st.error(f"‚ùå Error reading file: {e}")
        st.stop()

    with st.expander("üìÑ Preview Uploaded Data"):
        st.dataframe(df.head())


    # --------------------------------------------------------
    # VALIDATION
    # --------------------------------------------------------
    missing_cols = [c for c in REQUIRED_COLUMNS if c not in df.columns]

    if missing_cols:
        st.error(f"‚ùå Missing columns: {missing_cols}")
        st.stop()
    else:
        st.success("Column validation passed.")


    # --------------------------------------------------------
    # CLEAN + CONVERT
    # --------------------------------------------------------
    def _clean_numeric(series: pd.Series) -> pd.Series:
        # Handle common messy inputs: commas, currency, parentheses for negatives, percent signs
        ser = series.astype(str).str.strip()
        ser = ser.str.replace(r"[,$]", "", regex=True)
        ser = ser.str.replace(r"\(([^)]+)\)", r"-\1", regex=True)  # (123) -> -123
        ser = ser.str.replace("%", "", regex=False)
        return pd.to_numeric(ser, errors="coerce")

    replacement_counts = {}
    for col in REQUIRED_COLUMNS:
        cleaned = _clean_numeric(df[col])
        replacement_counts[col] = int(cleaned.isna().sum())
        # Replace non-numeric with 0 as requested
        df[col] = cleaned.fillna(0)

    total_replaced = sum(replacement_counts.values())
    if total_replaced > 0:
        st.warning(f"‚ö†Ô∏è Replaced {total_replaced} non-numeric/invalid entries with 0 across numeric columns.")
    else:
        st.success("‚úÖ All numeric columns validated.")


    # --------------------------------------------------------
    # FEATURE ENGINEERING
    # --------------------------------------------------------
    features = compute_features(df)

    model_cols = list(getattr(model, "feature_names_", []))
    if not model_cols:
        st.error("Model feature names missing; ensure CatBoost model saved with feature_names_.")
        st.stop()
    features = features.reindex(columns=model_cols, fill_value=0.0)

    # ------------------------
    # Guardrails (vectorized)
    # ------------------------
    assets = df["total_assets"]
    net_sales = df["net_sales"]
    total_revenue = df["total_revenue"]
    liabilities = df["total_liabilities"]
    current_assets = df["current_assets"]
    current_liab = df["total_current_liabilities"]

    base_proba = model.predict(features)
    proba = base_proba.copy()

    issues = {}

    bad_assets = assets <= 0
    if bad_assets.any():
        proba[bad_assets] = np.maximum(proba[bad_assets], 0.99)
        issues["assets<=0"] = int(bad_assets.sum())

    bad_revenue = (net_sales <= 0) | (total_revenue <= 0)
    if bad_revenue.any():
        proba[bad_revenue] = np.maximum(proba[bad_revenue], 0.85)
        issues["revenue<=0"] = int(bad_revenue.sum())

    leverage = liabilities / assets.clip(lower=1e-6)
    high_lev = leverage >= 5
    if high_lev.any():
        proba[high_lev] = np.maximum(proba[high_lev], 0.75)
        issues["leverage>=5x"] = int(high_lev.sum())

    current_ratio = current_assets / current_liab.clip(lower=1e-6)
    weak_liq = current_ratio < 0.7
    if weak_liq.any():
        proba[weak_liq] = np.maximum(proba[weak_liq], 0.35)
        issues["current_ratio<0.7"] = int(weak_liq.sum())

    if issues:
        summary = " | ".join([f"{k}: {v} rows" for k, v in issues.items()])
        st.warning(f"Guardrails applied to portfolio: {summary}")

    df["bankruptcy_probability"] = proba

    # Update quick stats for sidebar
    q = st.session_state.get("quick_stats", {})
    q.update({
        "portfolio_avg": float(np.mean(proba)),
        "companies": int(df.shape[0])
    })
    st.session_state["quick_stats"] = q

    # Risk band
    def band(p):
        return (
            "Critical" if p >= 0.50 else
            "High" if p >= 0.25 else
            "Moderate" if p >= 0.10 else
            "Low"
        )

    df["risk_band"] = df["bankruptcy_probability"].apply(band)


    # --------------------------------------------------------
    # KPI METRICS
    # --------------------------------------------------------
    st.markdown("## üìà Portfolio Summary")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown(f"<div class='metric-card'><h3>Total Companies</h3><h2>{df.shape[0]}</h2></div>", unsafe_allow_html=True)

    with col2:
        st.markdown(f"<div class='metric-card'><h3>Average Risk</h3><h2>{df['bankruptcy_probability'].mean():.2%}</h2></div>", unsafe_allow_html=True)

    with col3:
        critical_count = (df["risk_band"] == "Critical").sum()
        st.markdown(f"<div class='metric-card'><h3>Critical Risk Count</h3><h2>{critical_count}</h2></div>", unsafe_allow_html=True)

    with col4:
        st.markdown(f"<div class='metric-card'><h3>Median Risk</h3><h2>{df['bankruptcy_probability'].median():.2%}</h2></div>", unsafe_allow_html=True)


    # --------------------------------------------------------
    # ADVANCED FILTERING
    # --------------------------------------------------------
    st.markdown("## üéõ Filters")

    with st.expander("üîé Show Filters", expanded=False):

        industries = sorted(df["MajorGroup"].unique())
        selected_industries = st.multiselect("Industry Filter", industries, default=industries)

        risk_levels = ["Low", "Moderate", "High", "Critical"]
        selected_risk = st.multiselect("Risk Bands", risk_levels, default=risk_levels)

        rev_min = float(df["net_sales"].min())
        rev_max = float(df["net_sales"].max())
        if rev_min == rev_max:
            rev_max = rev_min + 1.0  # avoid Streamlit slider min==max error

        min_rev, max_rev = st.slider(
            "Revenue Range",
            rev_min,
            rev_max,
            (rev_min, rev_max)
        )

        # Apply filters
        filtered_df = df[
            (df["MajorGroup"].isin(selected_industries)) &
            (df["risk_band"].isin(selected_risk)) &
            (df["net_sales"].between(min_rev, max_rev))
        ]

        st.success(f"Filtered portfolio size: {filtered_df.shape[0]}")


    # --------------------------------------------------------
    # RISK DISTRIBUTION
    # --------------------------------------------------------
    st.markdown("## üìâ Risk Distribution")

    fig = px.histogram(
        filtered_df,
        x="bankruptcy_probability",
        nbins=40,
        color="risk_band",
        color_discrete_map={
            "Low": "#10B981",
            "Moderate": "#FBBF24",
            "High": "#F59E0B",
            "Critical": "#EF4444",
        },
        title="Distribution of Bankruptcy Risk"
    )

    st.plotly_chart(fig, use_container_width=True)


    # --------------------------------------------------------
    # INDUSTRY HEATMAP
    # --------------------------------------------------------
    st.markdown("## üå° Industry Heatmap")

    heatmap_fig = plot_industry_heatmap(filtered_df, industry_col="MajorGroup")
    st.plotly_chart(heatmap_fig, use_container_width=True)


    # --------------------------------------------------------
    # TOP 10 RISKIEST
    # --------------------------------------------------------
    st.markdown("## üî• Top 10 Highest Risk Companies")

    st.dataframe(filtered_df.sort_values("bankruptcy_probability", ascending=False).head(10))


    # --------------------------------------------------------
    # EXPORT OPTIONS
    # --------------------------------------------------------
    st.markdown("## üì• Export Options")

    # Export CSV
    csv_data = filtered_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label="Download CSV",
        data=csv_data,
        file_name="portfolio_filtered.csv",
        mime="text/csv"
    )

    # Export Excel
    excel_buffer = io.BytesIO()
    filtered_df.to_excel(excel_buffer, index=False)
    st.download_button(
        label="Download Excel",
        data=excel_buffer.getvalue(),
        file_name="portfolio_filtered.xlsx"
    )

    # Export PDF (lite version)
    st.info("Full multi-company PDF reports will be added in Phase 3.")